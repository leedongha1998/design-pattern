# 디자인 패턴 학습 체크리스트 (실무 적용용)

아래 체크리스트는 패턴을 "암기"가 아닌 "적용" 관점으로 공부하기 위한 기준입니다.

## 1) 패턴 선택 전
- [ ] 현재 코드의 문제가 무엇인지 한 문장으로 설명할 수 있는가?
- [ ] 패턴 없이도 해결 가능한 단순 문제는 아닌가?
- [ ] 변경 가능성이 높은 지점이 어디인지 식별했는가?

## 2) 패턴 적용 시
- [ ] 인터페이스/추상화가 과도하지 않은가?
- [ ] 새 기능 추가 시 기존 코드 수정량이 줄어드는가?
- [ ] 의존 관계가 단방향으로 유지되는가?
- [ ] 스프링 DI(@Component, @Bean)와 자연스럽게 연결되는가?

## 3) 테스트 관점
- [ ] 핵심 정책(전략, 생성, 이벤트, 캐시)이 단위 테스트 가능한가?
- [ ] Mock/Fake로 교체가 쉬운 구조인가?
- [ ] 리팩터링 후 테스트 수/가독성이 개선되었는가?

## 4) 운영 관점
- [ ] 로깅 포인트가 충분한가?
- [ ] 실패 시 예외 처리 및 재시도 전략이 있는가?
- [ ] 성능 병목(반복 호출, 원격 I/O)을 줄이는 구조인가?

## 5) 회고 질문
- [ ] 이 패턴이 없으면 어떤 문제가 반복되는가?
- [ ] 6개월 뒤 신규 팀원이 이해하기 쉬운가?
- [ ] 패턴을 제거해도 될 정도로 단순한 영역은 아닌가?

---

## 패턴별 실무 포인트 한 줄 요약
- **Strategy**: 정책 교체가 잦으면 반드시 고려.
- **Factory Method**: 생성 규칙이 복잡해질수록 효과적.
- **Template Method**: 절차는 같고 단계만 다를 때 유리.
- **Observer**: 후처리를 느슨하게 분리할 때 유리.
- **Proxy**: 캐시/보안/로깅 같은 횡단 관심사 분리에 적합.
- **Decorator**: 기존 코드 수정 없이 기능을 덧붙이기 좋음.
- **Adapter**: 레거시/외부 시스템 연동 시 인터페이스 변환에 유리.
- **Facade**: 복잡한 서브시스템을 단순 API 하나로 감쌀 때 유리.
- **Chain of Responsibility**: 검증/승인 등 단계형 처리 흐름 분리에 유리.
